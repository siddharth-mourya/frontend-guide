# Redux

## ‚ö° Quick Revision
- **Predictable state container**: Single source of truth with immutable updates
- **Three principles**: Single store, state is read-only, changes via pure functions (reducers)
- **Redux Toolkit (RTK)**: Modern Redux with less boilerplate, includes createSlice, configureStore
- **Thunks**: Handle async actions, access dispatch and getState
- **Common pitfall**: Mutating state directly instead of returning new objects
- **When to use**: Complex state logic, time-travel debugging, sharing state across distant components

```jsx
// Redux Toolkit slice
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

export const fetchUser = createAsyncThunk(
  'user/fetchUser',
  async (userId, { rejectWithValue }) => {
    try {
      const response = await api.getUser(userId);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

const userSlice = createSlice({
  name: 'user',
  initialState: {
    data: null,
    loading: false,
    error: null,
  },
  reducers: {
    clearError: (state) => {
      state.error = null;
    },
    updateProfile: (state, action) => {
      state.data = { ...state.data, ...action.payload };
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUser.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUser.fulfilled, (state, action) => {
        state.loading = false;
        state.data = action.payload;
      })
      .addCase(fetchUser.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

export const { clearError, updateProfile } = userSlice.actions;
export default userSlice.reducer;
```

---

## üß† Deep Understanding

<details>
<summary>Why this exists</summary>
Redux was created by Dan Abramov to solve **state management complexity** in large React applications:

**Problems Redux Solves:**
1. **Unpredictable state updates**: Multiple components modifying shared state
2. **Debugging difficulty**: Hard to track when/where/why state changed
3. **Component coupling**: Components tightly coupled through prop drilling
4. **Async complexity**: Managing loading states, errors, and race conditions

**Core Philosophy:**
- **Predictability**: Same input always produces same output
- **Centralization**: Single source of truth
- **Debuggability**: Time travel, action logs, state snapshots
- **Testability**: Pure functions are easy to test

**Redux Data Flow:**
```
UI Dispatch ‚Üí Action ‚Üí Reducer ‚Üí Store ‚Üí UI Update
```
</details>

<details>
<summary>How it works</summary>
Redux implements the **Flux architecture pattern** with these core concepts:

**1. Store - Single Source of Truth:**
```jsx
import { configureStore } from '@reduxjs/toolkit';
import userSlice from './userSlice';
import postsSlice from './postsSlice';

const store = configureStore({
  reducer: {
    user: userSlice,
    posts: postsSlice,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],
      },
    }),
});
```

**2. Actions - What Happened:**
```jsx
// Action creators (automatically generated by createSlice)
const actions = {
  increment: (amount) => ({ type: 'counter/increment', payload: amount }),
  decrement: () => ({ type: 'counter/decrement' }),
};
```

**3. Reducers - How State Changes:**
```jsx
// Pure function: (state, action) => newState
function counterReducer(state = { value: 0 }, action) {
  switch (action.type) {
    case 'counter/increment':
      return { ...state, value: state.value + action.payload };
    case 'counter/decrement':
      return { ...state, value: state.value - 1 };
    default:
      return state;
  }
}
```

**4. Selectors - Derived State:**
```jsx
import { createSelector } from '@reduxjs/toolkit';

// Basic selector
const selectUser = (state) => state.user;

// Memoized selector
const selectUserPosts = createSelector(
  [(state) => state.user.id, (state) => state.posts.items],
  (userId, posts) => posts.filter(post => post.authorId === userId)
);
```

**5. Middleware - Side Effects:**
```jsx
// Custom middleware
const loggerMiddleware = (store) => (next) => (action) => {
  console.log('Dispatching:', action);
  const result = next(action);
  console.log('New state:', store.getState());
  return result;
};
```
</details>

<details>
<summary>Common misconceptions</summary>
**‚ùå "Redux is always necessary"**
- Start with local state, useContext for simple global state
- Use Redux when you need time travel debugging, complex async flows, or sharing state across distant components

**‚ùå "Redux Toolkit is optional"**
- RTK is the **official, opinionated way** to write Redux
- Reduces boilerplate by 90%, includes best practices

**‚ùå "Async actions need middleware"**
```jsx
// ‚ùå Manual thunk
function fetchUser(userId) {
  return async (dispatch, getState) => {
    dispatch({ type: 'FETCH_USER_START' });
    try {
      const user = await api.getUser(userId);
      dispatch({ type: 'FETCH_USER_SUCCESS', payload: user });
    } catch (error) {
      dispatch({ type: 'FETCH_USER_ERROR', payload: error.message });
    }
  };
}

// ‚úÖ createAsyncThunk handles loading states automatically
const fetchUser = createAsyncThunk(
  'user/fetchUser',
  async (userId) => {
    const response = await api.getUser(userId);
    return response.data;
  }
);
```

**‚ùå "Immutability is hard"**
```jsx
// ‚ùå Manual immutable updates
case 'UPDATE_NESTED':
  return {
    ...state,
    user: {
      ...state.user,
      profile: {
        ...state.user.profile,
        name: action.payload
      }
    }
  };

// ‚úÖ RTK uses Immer internally - write "mutative" logic
case 'UPDATE_NESTED':
  state.user.profile.name = action.payload; // Looks mutable, actually immutable
```
</details>

<details>
<summary>Interview angle</summary>
**Key Interview Questions:**

1. **"When would you choose Redux over Context?"**
   - Redux: Complex state logic, time travel debugging, middleware needs
   - Context: Simple global state, component tree data sharing

2. **"How does Redux handle immutability?"**
   - Redux Toolkit uses Immer for immutable updates
   - Reducers must be pure functions
   - State snapshots enable time travel

3. **"What's the difference between createSlice and createReducer?"**
   - createSlice: All-in-one (actions + reducer)
   - createReducer: Just the reducer with builder pattern

**Redux vs Alternatives:**
```jsx
// Redux Toolkit Query (RTK Query) vs React Query
const { data, error, isLoading } = useGetUserQuery(userId);

// Zustand (simpler alternative)
const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
}));
```

**Advanced Patterns:**

**1. Entity Adapter (Normalized State):**
```jsx
import { createEntityAdapter } from '@reduxjs/toolkit';

const postsAdapter = createEntityAdapter({
  selectId: (post) => post.id,
  sortComparer: (a, b) => b.date.localeCompare(a.date),
});

const postsSlice = createSlice({
  name: 'posts',
  initialState: postsAdapter.getInitialState({
    loading: false,
    error: null,
  }),
  reducers: {
    postAdded: postsAdapter.addOne,
    postUpdated: postsAdapter.updateOne,
    postRemoved: postsAdapter.removeOne,
  },
});

// Auto-generated selectors
const {
  selectAll: selectAllPosts,
  selectById: selectPostById,
  selectIds: selectPostIds,
} = postsAdapter.getSelectors((state) => state.posts);
```

**2. RTK Query for API State:**
```jsx
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const apiSlice = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  tagTypes: ['User', 'Post'],
  endpoints: (builder) => ({
    getUser: builder.query({
      query: (id) => `users/${id}`,
      providesTags: (result, error, id) => [{ type: 'User', id }],
    }),
    updateUser: builder.mutation({
      query: ({ id, ...patch }) => ({
        url: `users/${id}`,
        method: 'PATCH',
        body: patch,
      }),
      invalidatesTags: (result, error, { id }) => [{ type: 'User', id }],
    }),
  }),
});

export const { useGetUserQuery, useUpdateUserMutation } = apiSlice;
```

**Performance Considerations:**
- Use React.memo with useSelector for expensive components
- Create memoized selectors with createSelector
- Normalize state shape to avoid deep nesting
- Split large reducers into smaller, focused ones
</details>